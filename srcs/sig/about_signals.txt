signal, kill - можно использовать

ctrl-C, ctrl-D and ctrl-\

3	SIGQUIT	Сигнал остановки процесса пользователем с терминала (CTRL + \)
с дампом памяти. На новой строке пишет: ^\Quit: 3. если мы просто ничего 
не вводим в баше, но нажимаем ctrl + \, то ничего не печатается.

2	SIGINT	Сигнал остановки процесса пользователем с терминала (CTRL + C)
если мы просто ничего не вводим в баше, но нажимаем ctrl +c, то новая строка
печатается и все). Если cat без аргументов, то нажав ctrl + c, он завершит 
процесс и напечатает ^c (вот это кстати мб сама система делает), и тоже на 
новую строку перейдет.

9	SIGKILL	Безусловное завершение процесса (CTRL + D) - этот сигнал ни 
перехватить, ни игнорировать нельзя. 

SIGINT и SIGQUIT отправляются основной группе процессов данного терминала, 
оба сигнала приводят к завершению процесса, причем SIGQUIT еще и создает 
CORE-файл. 

core-файл - это файл с именем core или prog.core, создаваемый в текущем 
каталоге при аварийном завершении программы. В этот файл полностью 
записывается содержимое сегментов данных и стека на момент аварии. 
Core-файлы позволяют с помощью отладчика проанализировать причины аварии, 
например, узнать точку кода, в которой произошла ошибка, посмотреть 
значения переменных на момент аварии и т.п.

SIGTERM предписывает процессу завершиться. При перезагрузке системы всем 
процессам рассылается сначала SIGTERM, а затем, через 5 сек - SIGKILL. 
Это позволяет процессам "привести свои дела в порядок": например, 
редактор текстов может сохранить несохраненный файл во временном файле, 
с тем, чтобы потом (в начале след сеанса редактирования) предложить 
пользователю восстановить несохраненные изменения. 


Отправка сигнала. 

Отправитель - может быть процесс или операционная система. 
Получатель - всегда процесс. 

Используем системный вызов kill для отправки сигнала:
int kill(int target_pid, int sig_no);

 sig_no - номер подлежащего отправке сигнала (можно использовать макросы 
 вместо чисел). Если посылаем 0 (null signal), то будет проверена ошибка, 
 но никакого сигнала не будет отправлено.

target_pid - задает процесс(ы), которому(ым) следует отправить сигнал. 

Если pid > 0, то sig будет отправлен процессу, process ID которого будет 
равен pid . То есть это будет использоваться как номер процесса, которому 
следует подать сигнал.

Если pid = -1, сигнал посылается каждому процессу в системе, за исключением 
специальных системных процессов. Применяется проверка прав доступа. 
На системах GNU/Linux исключается лишь процесс.

Если pid < 0 (но не -1!), то sig будет отправлен группе процессов с 
соответствующем номером (по модулю).

Если pid = 0, Сигнал посылается каждому процессу в группе посылающего 
процесса.

Возвращаемое значение - в случае успешной обработки - 0, в случае 
ошибки - 1, и запишется ошибка в errno. 

про kill в оригинале: [https://pubs.opengroup.org/onlinepubs/009695399/functions/kill.html](https://pubs.opengroup.org/onlinepubs/009695399/functions/kill.html) 


Обработка сигналов.

Если не предпринять спец мер, то большинство сигналов завершают процесс, 
а некоторые сигналы типа (SIGCHLD) и вовсе игнорируются.

Процесс может для любого сигнала, кроме SIGKILL и SIGSTOP, установить свой 
режим обработки: вызов функции обработчика, игнорирование, или обработка 
по умолчанию. 

Функцию-обработчик должна быть вида: 

void handler(int s) {

/* код *

 Для установки обработчика можно использовать системный вызов signal()

SIG_IGN - игнорировать сигнал
SIG_DFL - установить обработку по умолчанию

Вызов signal() возвращает значение, соответствующее предыдущему 
режиму обработки для данного сигнала, либо SIG_ERR в случае ошибки. 

После установки функции-обработчика в случае, если кто-либо отправит 
нашему процессу сигнал, будет вызвана функция-обработчик (с параметром, 
равным номеру сигнала)

Программа, которая при нажатии ctrl-c сначала выдает сообщение, и лишь 
на 25й раз завершается.

```c
#include <signal.h>
#include <stdlib.h>

volatile static int i = 0;
const char message[] = "Press it again, I like it\n";

void handler(int) 
{
	signal(SIGINT, handler);
	i++;
	write(1, message, sizeof(message)-1);
}
int main()
{
	signal(SIGINT, handler);
	while(i < 25) pause(); // не выходим из программы, 
// ждем сигналов 
return (0);
}
```

Функция pause() приостанавливает выполнение программы до получения 
неигнорируемого сигнала. 

Можно было оставить тело цикла while пустым, но это бы привело к 
возникновению активного ожидания, а этого следует по возможности избегать, 
т.к. при активном ожидании процессор оказывается занят бессмысленной работой. 

Слово volatile в описании переменной i указывает компилятору, что 
значение переменной i может неожиданно измениться; короче, таким образом, 
компилятор не прибегает к методам оптимизации, основанным на предположениях 
о значении такой переменной (как я поняла, мы меньше нагружаем компилятор). 

Режим обработки сигнала SIGINT выставляется как в начале программы, 
так и при каждом получении сигнала, - это сделано для того, чтобы 
программа работала корректно в случае, если система, в которой мы 
ее запустили, поддерживает "классическую" семантику вызова signal();

вот тут хорошо про сигналы [https://habr.com/ru/company/ruvds/blog/326826/](https://habr.com/ru/company/ruvds/blog/326826/)  + у Столярова есть [http://www.stolyarov.info/books/pdf/osintro.pdf](http://www.stolyarov.info/books/pdf/osintro.pdf) (начиная со страницы 103)

Сначала вызываем в мейнике signal() два раза - один - с функцией 
обработки SIGINT, второй - с функцией обработки SIGQUIT. 

Далее - пишем функции-обработчики сигналов. 

/b/b - возвращает курсор назад



в дочернем процессе (после форка):

signal(SIGINT, SIG_DFL);

SIG_IGN - надо добавить в родительский

если хочется сделать прям как в баше, то можно добавить, handler в дочерний процесс, который после дефолтного поведения напечатает новую строку (или то, что нужно просто).